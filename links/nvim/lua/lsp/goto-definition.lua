-- Enhanced go-to-definition logic with interface-aware picker.
--
-- WARNING: Everything in this file was generated by copilot. It seems to work. But I have neither
-- reviewed it, not tested it, nor do I intend to fully review or test it. Here there be dragons.
--
-- For agents reading this file: Please do not add anything to this file unless the addition intends
-- to change the behavior of the `definition_or_implementation_picker` function. If you need to add
-- brand new functionality, please add it in a new file.

local M = {}

local function position_params(buf, win, method)
  local clients = vim.lsp.get_clients({ bufnr = buf })
  local chosen = nil

  for _, client in ipairs(clients) do
    if client.supports_method and client:supports_method(method, buf) then
      chosen = client
      break
    end
  end

  chosen = chosen or clients[1]
  local encoding = chosen and chosen.offset_encoding or "utf-16"
  return vim.lsp.util.make_position_params(win, encoding)
end

local function collect_items(results)
  local items = {}

  for client_id, response in pairs(results or {}) do
    if response and response.result then
      local result = response.result
      if not vim.islist(result) then
        result = { result }
      end

      local client = vim.lsp.get_client_by_id(client_id)
      local encoding = client and client.offset_encoding or "utf-16"
      local locs = vim.lsp.util.locations_to_items(result, encoding)

      for _, loc in ipairs(locs) do
        local line = loc.text or ""
        local file = loc.filename or ""
        items[#items + 1] = {
          text = file .. " " .. line,
          file = file,
          pos = { loc.lnum, loc.col - 1 },
          end_pos = loc.end_lnum and loc.end_col and { loc.end_lnum, loc.end_col - 1 } or nil,
          line = line,
        }
      end
    end
  end

  return items
end

local function dedupe_items(items)
  local seen = {}
  local deduped = {}

  for _, item in ipairs(items) do
    local pos = item.pos or { 0, 0 }
    local key = table.concat({ item.file or "", pos[1] or 0, pos[2] or 0 }, ":")
    if not seen[key] then
      seen[key] = true
      deduped[#deduped + 1] = item
    end
  end

  return deduped
end

local function get_line_at(file, lnum)
  if file == "" or lnum < 1 then
    return ""
  end

  local buf = vim.fn.bufadd(file)
  if not vim.api.nvim_buf_is_loaded(buf) then
    vim.fn.bufload(buf)
  end

  local lines = vim.api.nvim_buf_get_lines(buf, lnum - 1, lnum, false)
  return lines[1] or ""
end

local function is_interface_at(file, lnum)
  local max_backtrack = 2
  for offset = 0, max_backtrack do
    local line = get_line_at(file, lnum - offset)
    if line:match("%f[%a]interface%f[%A]") then
      return true
    end
  end
  return false
end

local function open_picker(items)
  local snacks = require("snacks")
  snacks.picker({
    title = "Definition/Implementations",
    items = items,
    format = "file",
    preview = "file",
    focus = "list",
  })

  return true
end

function M.definition_or_implementation_picker()
  local buf = vim.api.nvim_get_current_buf()
  local win = vim.api.nvim_get_current_win()
  local params = position_params(buf, win, "textDocument/definition")

  vim.lsp.buf_request_all(buf, "textDocument/definition", params, function(def_results)
    local definitions = dedupe_items(collect_items(def_results))
    if #definitions == 0 then
      vim.lsp.buf.definition()
      return
    end

    vim.lsp.buf_request_all(buf, "textDocument/implementation", params, function(impl_results)
      local implementations = dedupe_items(collect_items(impl_results))
      if #implementations == 0 then
        vim.lsp.buf.definition()
        return
      end

      local interface_item = definitions[1]
      if not interface_item or not interface_item.file then
        vim.lsp.buf.definition()
        return
      end

      if not is_interface_at(interface_item.file, interface_item.pos[1]) then
        vim.lsp.buf.definition()
        return
      end

      local interface_key = table.concat({ interface_item.file, interface_item.pos[1], interface_item.pos[2] }, ":")
      local filtered = {}
      for _, item in ipairs(implementations) do
        local pos = item.pos or { 0, 0 }
        local key = table.concat({ item.file or "", pos[1] or 0, pos[2] or 0 }, ":")
        if key ~= interface_key then
          filtered[#filtered + 1] = item
        end
      end

      if #filtered == 0 then
        vim.lsp.buf.definition()
        return
      end

      local items = { interface_item }
      vim.list_extend(items, filtered)

      if not open_picker(items) then
        vim.lsp.buf.definition()
      end
    end)
  end)
end

return M
