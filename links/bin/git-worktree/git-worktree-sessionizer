#!/usr/bin/env bash
# Interactive git worktree manager with tmux integration
# Use with: bind-key w display-popup -E 'git-worktree-sessionizer'

set -eo pipefail

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Add all bin subdirectories to PATH for helper scripts
while IFS= read -r -d '' dir; do
  export PATH="$dir:$PATH"
done < <(find "$HOME/.dotfiles/links/bin" -type d -print0 2>/dev/null | sort -zr)

# Save the current directory's git repo (if any) before we do anything else
# Use --git-common-dir to get the main repo path even when in a worktree
INITIAL_REPO=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null | xargs -r dirname 2>/dev/null || true)

WORKTREES_BASE="$HOME/worktrees"

# Function to list all worktrees from ~/worktrees only
list_all_worktrees() {
    fd --hidden --max-depth 5 '^\.git$' ~/worktrees |
        cut -f5- -d'/' |
        grep -v 'nc-common-tools\/\.git'
}

# Function to list all branches from a repository (local and remote)
list_branches() {
    local repo="$1"
    {
        # Local branches
        git -C "$repo" branch --format="%(refname:short)" 2>/dev/null
        # Remote branches (without origin/ prefix for cleaner display)
        git -C "$repo" branch -r --format="%(refname:short)" 2>/dev/null | \
            grep -v "HEAD" | \
            sed 's|^origin/||'
    } | sort -u
}

# Function to get repo name from path
get_repo_name() {
    basename "$1"
}

# Function to get current git repo if we're in one
get_current_repo() {
    echo "$INITIAL_REPO"
}

# No need to export functions - we use standalone scripts for previews

select_worktree() {
    local result
    
    result=$(
        list_all_worktrees | fzf-tmux -p 100%,100% \
            --ansi --border-label ' Git Worktrees ' --prompt 'ðŸŒ³  ' \
            --header '^n: new worktree (from current repo)  ^d: force delete  ESC: exit' \
            --preview "$SCRIPT_DIR/git-worktree-preview {}" \
            --bind 'tab:down,btab:up' \
            --bind 'ctrl-n:become(echo __CREATE_NEW__)' \
            --bind "ctrl-d:reload($SCRIPT_DIR/git-worktree-delete {} 2>&1; list_all_worktrees)" \
            --expect=ctrl-n
    ) || return 0  # Exit cleanly on ESC/Ctrl-C

    local key=$(echo "$result" | head -1)
    local selection=$(echo "$result" | tail -1)

    if [[ "$selection" == "__CREATE_NEW__" ]] || [[ "$key" == "ctrl-n" ]]; then
        # Check if we're currently in a git repo
        local current_repo
        current_repo=$(get_current_repo)

        if [ -n "$current_repo" ]; then
            # Use current repo for branch selection
            select_branch "$current_repo"
        else
            # Not in a repo
            echo "" >&2
            echo "Error: Not in a git repository!" >&2
            echo "Please run this from within a git repository to create a new worktree." >&2
            echo "" >&2
            sleep 3
            return 0
        fi
    elif [ -n "$selection" ]; then
        sesh connect "$selection"
    fi
}

select_branch() {
    local repo="$1"
    local repo_name
    repo_name=$(get_repo_name "$repo")

    local branch
    branch=$(
        list_branches "$repo" | fzf-tmux -p 100%,100% \
            --ansi --border-label " Select Branch from $repo_name " --prompt 'ðŸŒ¿  ' \
            --header 'Select branch to create worktree  ESC: cancel' \
            --preview "$SCRIPT_DIR/git-worktree-preview-branch '$repo' {}" \
            --bind 'tab:down,btab:up'
    ) || return 0  # Exit cleanly on ESC/Ctrl-C

    if [ -n "$branch" ]; then
        # Create the worktree
        local worktree_path
        local create_output

        # Capture both stdout and stderr
        create_output=$(git-worktree-create "$repo" "$branch" 2>&1)
        local exit_code=$?

        if [ $exit_code -eq 0 ]; then
            worktree_path=$(echo "$create_output" | tail -1)

            if [ -n "$worktree_path" ] && [ -d "$worktree_path" ]; then
                # Connect to the new worktree
                sesh connect "$worktree_path"
                return 0
            fi
        fi

        # Error occurred - show it and go back
        echo "" >&2
        echo "Error: $create_output" >&2
        echo "" >&2
        return 0
    fi
}

# Export functions for subshells
export -f list_all_worktrees

# Main entry point
select_worktree
